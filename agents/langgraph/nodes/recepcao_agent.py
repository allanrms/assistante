# dialog_test/nodes/recepcao_agent.py
"""
Agente de Recep√ß√£o - Atendimento Inicial e Coleta de Dados

Respons√°vel por:
- Receber o contato inicial
- Coletar informa√ß√µes do paciente (nome, email)
- Rotear para o agente de agenda quando necess√°rio
"""

from typing import TYPE_CHECKING
from datetime import datetime
from pathlib import Path

from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage
from langchain_core.tools import tool
from langgraph.prebuilt import create_react_agent
from langgraph.graph import END

from agents.langgraph.nodes.utils import debug_langgraph_messages, validate_agenda_request, validate_agenda_response

if TYPE_CHECKING:
    from core.models import Contact

# Configura√ß√£o do LLM
# Temperature reduzida de 0.6 para 0.1 para maior consist√™ncia nas respostas
recepcao_llm = ChatOpenAI(model="gpt-4o", temperature=0.1)

# Carregar prompt base
PROMPT_RECEPCAO_BASE = (Path(__file__).parent.parent / "prompts" / "recepcao.md").read_text()


def get_prompt_recepcao() -> str:
    """Retorna o prompt de recep√ß√£o com a data atual e informa√ß√µes do contato injetadas."""
    hoje = datetime.now()
    data_formatada = hoje.strftime("%d/%m/%Y")
    dia_semana = hoje.strftime("%A")

    # Traduzir dia da semana para portugu√™s
    dias_pt = {
        "Monday": "segunda-feira",
        "Tuesday": "ter√ßa-feira",
        "Wednesday": "quarta-feira",
        "Thursday": "quinta-feira",
        "Friday": "sexta-feira",
        "Saturday": "s√°bado",
        "Sunday": "domingo"
    }
    dia_semana_pt = dias_pt.get(dia_semana, dia_semana)

    # Contexto temporal
    contexto_data = f"\n\n---\n\n## üìÖ Contexto Temporal\n\n**Data de hoje:** {data_formatada} ({dia_semana_pt})\n"

    return PROMPT_RECEPCAO_BASE + contexto_data


def create_recepcao_tools(contact: "Contact"):
    """Cria as ferramentas de recep√ß√£o para atualizar informa√ß√µes do contato"""

    @tool
    def atualizar_nome_contato(nome: str) -> str:
        """
        Atualiza o nome do contato no sistema.
        Par√¢metros:
        - nome: Nome completo do contato
        """
        print(f"üîß [TOOL CALL] atualizar_nome_contato - Nome: {nome}")
        try:
            if not nome or len(nome.strip()) < 2:
                return "‚ùå Nome inv√°lido. Por favor, forne√ßa um nome v√°lido."

            contact.name = nome.strip()
            contact.save(update_fields=['name', 'updated_at'])

            print(f"‚úÖ [TOOL] Nome atualizado: {contact.name}")
            return f"‚úÖ Nome atualizado com sucesso para: {contact.name}"
        except Exception as e:
            print(f"‚ùå [TOOL] Erro ao atualizar nome: {e}")
            return f"‚ùå Erro ao atualizar nome: {str(e)}"

    @tool
    def consultar_agendamentos_contato() -> str:
        """
        Consulta as consultas/agendamentos marcados para este contato.
        Retorna lista de consultas futuras e passadas.
        """
        print(f"üîß [TOOL CALL] consultar_agendamentos_contato")
        try:
            from datetime import datetime, date
            from core.models import Appointment

            # Buscar todos os agendamentos do contato ordenados por data
            appointments = contact.appointments.all().order_by('date', 'time')

            # ‚úÖ Se n√£o encontrar, retorna imediatamente
            if not appointments.exists():
                return "üìÖ Voc√™ n√£o possui consultas marcadas no momento."

            hoje = date.today()
            agora = datetime.now().time()

            future_appointments = []
            past_appointments = []

            for apt in appointments:
                if apt.date > hoje or (apt.date == hoje and apt.time >= agora):
                    future_appointments.append(apt)
                else:
                    past_appointments.append(apt)

            resultado = []

            # Futuras
            if future_appointments:
                resultado.append("üìÖ Consultas Agendadas (Pr√≥ximas):\n")
                for i, apt in enumerate(future_appointments, 1):
                    data_formatada = f"{apt.date.strftime('%d/%m/%Y')} √†s {apt.time.strftime('%H:%M')}"
                    dia_semana_pt = {
                        'Monday': 'segunda-feira',
                        'Tuesday': 'ter√ßa-feira',
                        'Wednesday': 'quarta-feira',
                        'Thursday': 'quinta-feira',
                        'Friday': 'sexta-feira',
                        'Saturday': 's√°bado',
                        'Sunday': 'domingo'
                    }.get(apt.date.strftime('%A'), apt.date.strftime('%A'))
                    resultado.append(f"{i}. {data_formatada} ({dia_semana_pt})")

            # Passadas (√∫ltimas 3)
            if past_appointments:
                if future_appointments:
                    resultado.append("")  # linha em branco
                resultado.append("üìã Consultas Anteriores (Hist√≥rico):\n")
                for i, apt in enumerate(list(reversed(past_appointments))[:3], 1):
                    data_formatada = f"{apt.date.strftime('%d/%m/%Y')} √†s {apt.time.strftime('%H:%M')}"
                    resultado.append(f"{i}. {data_formatada}")

            # ‚úÖ Retorna sem loop adicional
            return "\n".join(resultado) if resultado else "üìÖ Voc√™ n√£o possui consultas marcadas no momento."

        except Exception as e:
            print(f"‚ùå [TOOL] Erro ao consultar agendamentos: {e}")
            return f"‚ùå Erro ao consultar agendamentos: {str(e)}"

    @tool
    def cancelar_agendamento_contato(data: str, hora: str) -> str:
        """
        Cancela uma consulta/agendamento marcado do contato.
        Remove do Google Calendar e do sistema.

        Par√¢metros:
        - data: Data do agendamento no formato DD/MM/YYYY
        - hora: Hor√°rio do agendamento no formato HH:MM
        """
        print("\n" + "="*80)
        print(f"üîß [TOOL CALL] cancelar_agendamento_contato")
        print(f"   üìÖ Data: {data}")
        print(f"   ‚è∞ Hora: {hora}")
        print(f"   üìû Contact: {contact.phone_number}")
        print("="*80)
        try:
            from datetime import datetime
            from core.models import Appointment
            from google_calendar.services import GoogleCalendarService

            # Parse data e hora
            try:
                data_obj = datetime.strptime(data, '%d/%m/%Y').date()
                hora_obj = datetime.strptime(hora, '%H:%M').time()
                print(f"‚úÖ [TOOL] Data/hora parseadas: {data_obj} {hora_obj}")
            except ValueError as e:
                print(f"‚ùå [TOOL] Erro ao fazer parse de data/hora: {e}")
                return "‚ùå Formato de data ou hora inv√°lido. Use DD/MM/YYYY para data e HH:MM para hora."

            # Buscar o agendamento
            print(f"üîç [TOOL] Buscando agendamento para data={data_obj}, time={hora_obj}")
            try:
                appointment = contact.appointments.get(date=data_obj, time=hora_obj)
                print(f"‚úÖ [TOOL] Agendamento encontrado: #{appointment.id}")
            except Appointment.DoesNotExist:
                print(f"‚ùå [TOOL] Nenhum agendamento encontrado")
                return f"‚ùå N√£o encontrei nenhuma consulta marcada para {data} √†s {hora}."
            except Appointment.MultipleObjectsReturned:
                print(f"‚ö†Ô∏è [TOOL] M√∫ltiplos agendamentos encontrados")
                return f"‚ùå Encontrei m√∫ltiplas consultas para {data} √†s {hora}. Por favor, entre em contato com a cl√≠nica."

            # Guardar informa√ß√µes para a mensagem de confirma√ß√£o
            data_formatada = appointment.date.strftime('%d/%m/%Y')
            hora_formatada = appointment.time.strftime('%H:%M')

            # Deletar do Google Calendar se tiver event_id
            calendar_deleted = False
            if appointment.calendar_event_id:
                print(f"üìÖ [TOOL] Deletando evento do Google Calendar: {appointment.calendar_event_id}")
                try:
                    calendar_service = GoogleCalendarService()
                    success, message = calendar_service.delete_event(contact.id, appointment.calendar_event_id)

                    if success:
                        print(f"‚úÖ [TOOL] Evento deletado do Google Calendar")
                        calendar_deleted = True
                    else:
                        print(f"‚ö†Ô∏è [TOOL] Erro ao deletar do Calendar: {message}")
                        # Continua mesmo se falhar no Calendar
                except Exception as cal_error:
                    print(f"‚ö†Ô∏è [TOOL] Erro ao acessar Google Calendar: {cal_error}")
                    # Continua mesmo se falhar no Calendar
            else:
                print(f"‚ÑπÔ∏è [TOOL] Agendamento n√£o tem event_id do Google Calendar")

            # Deletar o Appointment do banco
            appointment_id = appointment.id
            appointment.delete()
            print(f"‚úÖ [TOOL] Appointment #{appointment_id} deletado do banco de dados")

            # Mensagem de sucesso
            if calendar_deleted:
                return f"""‚úÖ Consulta cancelada com sucesso!
üìÖ Data: {data_formatada}
‚è∞ Hor√°rio: {hora_formatada}

O agendamento foi removido do sistema e do Google Calendar."""
            else:
                return f"""‚úÖ Consulta cancelada!
üìÖ Data: {data_formatada}
‚è∞ Hor√°rio: {hora_formatada}

O agendamento foi removido do sistema."""

        except Exception as e:
            print(f"‚ùå [TOOL] Erro ao cancelar agendamento: {e}")
            import traceback
            traceback.print_exc()
            return f"‚ùå Erro ao cancelar agendamento: {str(e)}"

    return [
        atualizar_nome_contato,
        consultar_agendamentos_contato,
        cancelar_agendamento_contato
    ]


def create_recepcao_node():
    """Cria o n√≥ de recep√ß√£o ‚Äî cada execu√ß√£o l√™ o contact e o client do state."""

    def recepcao_node(state: "State") -> dict:
        print("üëã [RECEP√á√ÉO NODE] Iniciando processamento...")

        # ‚öôÔ∏è Pega o contato e o cliente do state
        contact = state.contact
        client = state.client

        # Criar tools dinamicamente com o contato atual
        recepcao_tools = create_recepcao_tools(contact)

        # Criar agente React com as tools
        recepcao_agent = create_react_agent(recepcao_llm, recepcao_tools)

        # Gerar prompt com data atual e informa√ß√µes do contact
        prompt_atual = get_prompt_recepcao()
        messages = [SystemMessage(content=prompt_atual)] + list(state.history)

        print(f"üìù [RECEP√á√ÉO NODE] √öltima mensagem do hist√≥rico: "
              f"{state.history[-1].content if state.history else 'Nenhuma'}")

        # Executar agente com tools
        result = recepcao_agent.invoke({"messages": messages})

        # Debug: Mostrar TODAS as mensagens do resultado (incluindo ToolMessages)
        debug_langgraph_messages(result["messages"], node_name="RECEP√á√ÉO NODE")

        # Verificar se alguma ToolMessage cont√©m [AGENDA_REQUEST]
        from langchain_core.messages import ToolMessage
        for msg in result["messages"]:
            if isinstance(msg, ToolMessage) and "[AGENDA_REQUEST]" in msg.content:
                print("üéØ [RECEP√á√ÉO NODE] [AGENDA_REQUEST] detectado em ToolMessage ‚Äî roteando para agenda")
                is_valid, agenda_request = validate_agenda_request(msg.content)
                if is_valid:
                    return {
                        "history": [HumanMessage(content=agenda_request)],
                        "agent": "agenda"
                    }

        # Extrair mensagens AI do resultado
        ai_messages = [msg for msg in result["messages"] if isinstance(msg, AIMessage)]
        msg = ai_messages[-1].content.strip() if ai_messages else "Erro ao processar mensagem"

        print(f"üí¨ [RECEP√á√ÉO NODE] Resposta da Aline Atendimento: {msg[:200]}...")

        # Detectar se deve rotear para a agenda usando valida√ß√£o robusta (em AIMessage)
        is_valid_request, agenda_request = validate_agenda_request(msg)
        if is_valid_request:
            print("üéØ [RECEP√á√ÉO NODE] [AGENDA_REQUEST] v√°lido detectado em AIMessage ‚Äî roteando para agenda")
            next_agent = "agenda"
            return {
                "history": [HumanMessage(content=agenda_request)],
                "agent": next_agent
            }

        print("‚ö†Ô∏è [RECEP√á√ÉO NODE] Nenhum [AGENDA_REQUEST] v√°lido detectado ‚Äî resposta direta ao usu√°rio")

        # Formatar resposta se vier de agenda usando valida√ß√£o robusta
        is_valid_response, clean_msg = validate_agenda_response(msg)
        if is_valid_response:
            print("‚úÖ [RECEP√á√ÉO NODE] [AGENDA_RESPONSE] v√°lido detectado ‚Äî formatando para usu√°rio")
            msg = clean_msg

        return {
            "history": [AIMessage(content=msg)],
            "agent": END
        }

    return recepcao_node
